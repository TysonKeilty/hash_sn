#################################################################################
# Testing
#################################################################################  

import math
import numpy as np
import matplotlib.pyplot as plt
import time
from hash_aux import ut, en, op
from random import randint

# Distinct elements generated by a when iteratively rotating itself
# equal to the usual order of element (a >> e) in S_n
def order(a,t):
    
    e=[i for i in range(t)]
    a = op.a_rotate_b(a, e, t)
    a0 = a.copy()
    count = 1
    a = ut.comp(a, a)
    
    while a!=a0:
        a = ut.comp(a0, a)
        count = count+1
        
    return count

# Return rotation >> in the form of compositions in S_n
def a_rotate_b_comp(a, b, t, direction):

    if type(a) is int: a = en.int_to_per(a,t)
    if type(b) is int: b = en.int_to_per(b,t)
    if len(b)!=t: raise IndexError('Permutations are not same length!')
    if direction=='r':
        for i in range(t):
            if a[i]<t-1:
                b1 = b.copy()
                b2 = b.copy()
                b1.remove(b1[i])
                b1 = b1[t-1-a[i]:]+b1[:t-1-a[i]]
                b = b1[:i]+[b[i]]+b1[i:]
            else:
                b = b[1:]+b[:1]
            print('a'+str(i)+':',ut.comp(b, ut.per_inv(b2)))
        return b
    
    if direction=='l':
        for i in range(t):
            if a[i]<t-1:
                b1 = b.copy()
                b2 = b.copy()
                b1.remove(b1[i])
                b1 = b1[a[i]:]+b1[:a[i]]
                b = b1[:i]+[b[i]]+b1[i:]
            else:
                b = b[t-1:]+b[:t-1]
            print('a'+str(i)+':',ut.comp(b, ut.per_inv(b2)))
        return b

#   Return class sizes of mappings a:S_n-->S_n where a(b)=a>>b up to t = 11
#   In C++: t = 12 yields
#   d={1:64313031, 2:57725732, 3:38451932, 4:21182580, 5:10205298, 6:4448803, 7:1791110, 8:676342, 9:242495, 10:83621, 11:27720, 12:8811, 13:2815,
#       14:827, 15:256, 16:74, 17:28, 18:5, 19:5}
#   K=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
def classes(t):
    
    partitions = 5
    threshold = int((math.factorial(t)*0.5)/partitions)
    d1, d2, d3, d4, d5, d6={},{},{},{},{},{}
    e=[j for j in range(t)]
    
    start = time.time()
    start1 = start
    
    for i in range(math.factorial(t)):
        if i%1000000==0:
            length = len(d1)+len(d2)+len(d3)+len(d4)+len(d5)+len(d6)
            print(str(round((i/math.factorial(t))*100, 5))+'%'.ljust(5,' '),length)
            start = time.time()
            
        a = en.int_to_per(i, t)
        c = en.per_to_int(op.a_rotate_b(a, e, t),t)
        
        if len(d1)<threshold:
            if d1.get(c):
                d1[c]=d1[c]+1
            if not d1.get(c):
                d1[c]=1
        elif len(d2)<threshold:
            if d1.get(c):
                d1[c]=d1[c]+1
            elif d2.get(c):
                d2[c]=d2[c]+1
            else:
                d2[c]=1
        elif len(d3)<threshold:
            if d1.get(c):
                d1[c]=d1[c]+1
            elif d2.get(c):
                d2[c]=d2[c]+1
            elif d3.get(c):
                d3[c]=d3[c]+1
            else:
                d3[c]=1
        elif len(d4)<threshold:
            if d1.get(c):
                d1[c]=d1[c]+1
            elif d2.get(c):
                d2[c]=d2[c]+1
            elif d3.get(c):
                d3[c]=d3[c]+1
            elif d4.get(c):
                d4[c]=d4[c]+1
            else:
                d4[c]=1
        elif len(d5)<threshold:
            if d1.get(c):
                d1[c]=d1[c]+1
            elif d2.get(c):
                d2[c]=d2[c]+1
            elif d3.get(c):
                d3[c]=d3[c]+1
            elif d4.get(c):
                d4[c]=d4[c]+1
            elif d5.get(c):
                d5[c]=d5[c]+1
            else:
                d5[c]=1
        else:
            if d6.get(c):
                d6[c]=d6[c]+1
            if not d6.get(c):
                d6[c]=1

    print(time.time()-start1)

    S1 = list(d1.values())
    S2 = list(d2.values())
    S3 = list(d3.values())
    S4 = list(d4.values())
    S5 = list(d5.values())
    S6 = list(d6.values())

    K = list(set(S1))
    K = list(set(K+S2))
    K = list(set(K+S3))
    K = list(set(K+S4))
    K = list(set(K+S5))
    K = list(set(K+S6))

    maxi = max(K)
    print('')
    print('Max:',maxi)
    print('Min:',min(K))

    K.sort()
    print('')
    print('k'.ljust(5,' '),'Classes containing k elements'.ljust(35,' '))
    print(''.ljust(45,'-'))

    m = 0
    d={}
    
    for i in range(len(K)):

        d[K[i]]=S1.count(K[i])+S2.count(K[i])+S3.count(K[i])+S4.count(K[i])+S5.count(K[i])+S6.count(K[i])
        
        print(str(K[i]).ljust(5,' '), d[K[i]])
        m = m+d[K[i]]
        
    print('Number of mapping classes sigma_a:',m)
    
    plt.grid()
    plt.plot([K[i] for i in range(len(K))],list(d.values()))
    plt.title('t='+str(t))
    plt.xlabel('k')
    plt.ylabel('number of classes with k elements')
    plt.show()

# Overlay of class sizes
# choose t > 4 
def copies(t, overlay):
    
    plt.grid()
    plt.title('Number of copies of mappings t = 5, 6, 7, 8')#+str(t))
    plt.xlabel('a in Sn')
    plt.ylabel('copies of a')
    
    if overlay:
        threshold = 5
        
        for k in range(threshold, t+1):
            e=[i for i in range(k)]
            L=[]

            for i in range(math.factorial(threshold)):
                r = op.a_rotate_b(en.int_to_per(i, k),e, k)
                count = 0

                for j in range(math.factorial(k)):
                    if op.a_rotate_b(en.int_to_per(j, k),e, k)==r: count+=1

                L.append(count)
                
            # Number of classes
            plt.plot([i for i in range(math.factorial(threshold))],L[:math.factorial(threshold)])

        plt.show()

    else:
        threshold = math.factorial(t)
        e=[i for i in range(t)]
        L=[]
        
        for i in range(threshold):
            r = op.a_rotate_b(en.int_to_per(i, t),e, t)
            count = 0
            
            for j in range(math.factorial(t)):
                if op.a_rotate_b(en.int_to_per(j, t),e, t)==r: count+=1

            L.append(count)

        # Number of classes
        plt.plot([i for i in range(threshold)],L)
        plt.show()

def plots(plot):
    
    if plot==1:
        
        # Plot Number of mappings as t grows vs exp(t)
        L=[[9, 153809],[10, 1511923],[11, 16843800]]
        L_array_tr = np.transpose(np.array(L))
        plt.grid()
        plt.title('Number of mappings as t grows vs t! and exp(t)')
        plt.xlabel('t')
        plt.ylabel('number of mappings in tens of millions')
        
        # Number of classes
        plt.plot(list(L_array_tr[0]),list(L_array_tr[1]),color='b')
        
        # Number of elements
        plt.plot(list(L_array_tr[0]),[math.factorial(L_array_tr[0][i]) for i in range(len(L_array_tr[0]))],color='g')

        partition=[9+i/100 for i in range(200)]
        plt.plot(partition,[math.exp(partition[i]) for i in range(len(partition))],color='r')
        plt.show()
        
    if plot==2:
        
        # number of mappings as t grows
        L=[[5, 47],[6, 301],[7, 2149],[8, 16884],[9, 153809],[10, 1511923],[11, 16843800],[12, 199161485]]

        x = list(np.transpose(L[2:])[0])
        y=[list(np.transpose(L[2:])[1])[i]/math.factorial(x[i]) for i in range(len(L[2:]))]
        a = np.vstack([x, np.ones(len(x))]).T
        R = list(np.dot(np.linalg.inv(np.dot(a.T, a)), np.dot(a.T, y)))

        y1=[9, 12, 14, 18, 16, 19]
        R1 = list(np.dot(np.linalg.inv(np.dot(a.T, a)), np.dot(a.T, y1)))

        print(R)
        print(R1)
        
        L_array_tr = np.transpose(np.array(L))
        plt.grid()
        plt.title('ratio of classes')
        plt.xlabel('t')
        plt.ylabel('number of classes/t!')
        
        # ratio of classes vs t! ((number of classes/t!))
        plt.plot(list(L_array_tr[0]),[(L_array_tr[1][i]/math.factorial(L_array_tr[0][i])) for i in range(len(L))],color='b')

        # Regression least squares
        plt.plot([5, 12],[R[0]*5+R[1],R[0]*12+R[1]],'r')

        # Number of elements
        #plt.plot(list(L_array_tr[0]),[math.factorial(L_array_tr[0][i]) for i in range(len(L_array_tr[0]))],color='g')
        plt.show()

# Plots the image a1>>S_n ... a2>>S_n
# R=[a1, a2]
def randomness(t, R):
    
    for i in range(R[0],R[1]):
        
        L=[]
        a = en.int_to_per(i, t)
        
        for j in range(math.factorial(t)):
            L.append(en.per_to_int(op.a_rotate_b_inv(a, en.int_to_per(j, t), t),t))
            
        plt.title('a='+str(a))
        plt.xlabel('b')
        plt.ylabel('a>>b')
        plt.scatter([k for k in range(math.factorial(t))],L, 0.5)
        #plt.savefig('randomness_'+str(i)+'_'+str(t)+'.png')
        plt.show()
        plt.close()


# Test avalanch effect of construction >>
# a, b in integer form
# s -> block size, t-> factorial
def avalanch(a, b, s, t):
    
    plt.grid()
    plt.title('( b   <<^k   a )    vs    ( b+i   <<^k   a )    i, k = 1, 2, 3, 4, 5')
    blocksize = 2**s
    a = en.int_to_per(a, t)
    
    for j in range(5):
        b_it = b+j
        L=[b_it]

        for i in range(10):
            b_it = en.per_to_int(op.a_rotate_b_inv(a, en.int_to_per(b_it, t), t), t)%blocksize
            L.append(b_it)

        plt.plot([i for i in range(11)],L)

    plt.show()
    

# s -> blocksize multiple of 8 (1 char -> 1 byte -> 8 bits)
# t -> smallest factorial larger than 2**s
# ex: one_block_domain(16, 9)
def one_block_domain(s, t):
    
    L=[]
    d={}
    fact = math.factorial(t)
    blocksize = 2**s
    
    for i in range(blocksize):
        if i%10000==0: print(round(i*100/blocksize, 2),'%')

        block_bits_fill = format(i,'0'+str(s)+'b')
        block_bits = format(i,'b')

        # Length in char (bytes) * 2^(s/2)
        l = en.int_to_per(math.ceil(len(block_bits)/8)*(2**(s//2)),t)

        # Reverse half block * 2^(s/2)
        r = block_bits_fill[s//2:][::-1]
        r = en.int_to_per(en.bits_to_int(r)*2**(s//2),t)

        # Block
        block = en.int_to_per(i, t)
        h0 = op.a_rotate_b_inv(l, r, t)

        if h0[0]%2==0: result = en.per_to_int(op.a_rotate_b_inv(op.a_rotate_b(h0, block, t),block, t),t)%blocksize
        else: result = en.per_to_int(op.a_rotate_b_inv(op.a_rotate_b_inv(h0, block, t),block, t),t)%blocksize

        if not d.get(result):
            L.append(result)
            d[result]=0

    print('collisions:',blocksize-len(set(L)))
    print('Plotting...')
    plt.grid()
    plt.scatter([i for i in range(len(L))],L, 0.5)
    plt.show()
    plt.close()

def block_cipher_encrypt(B, k, n, t):
    
    L=[i for i in range(n)]

    if type(k) is int: k = en.int_to_per(k, n)
    elif type(k) is str: k = en.int_to_per(en.bits_to_int(en.string_to_bits(k)),n)
    elif type(k) is bin: k = en.int_to_per(en.bits_to_int(k),n)

    # XOR
    B = B ^ en.bits_to_int(''.join('01' for i in range(n//2)))
    B = format(B,'0'+str(n)+'b')[::-1]
    B = op.a_rotate_b_inv(k, list(B),n)
    B = B[::-1]
    B = op.a_rotate_b(k, B, n)

    return ''.join(B[i] for i in range(n))
    #return en.bits_to_int(''.join(B[i] for i in range(n))) #format(B,'0'+str(n)+'b')
